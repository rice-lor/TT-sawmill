<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sawmill Automation & Status</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: transparent;
            color: #f0f0f0;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .movable-window {
            position: fixed;
            background-color: rgba(30, 30, 30, 0.95);
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            resize: both;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
            top: 20px;
            left: 20px;
            width: 320px;
            min-width: 250px;
            height: 220px; /* Adjusted height after removing progress bar */
            min-height: 180px;
        }

        .header-bar {
            background-color: rgba(50, 50, 50, 0.9);
            padding: 6px 12px;
            cursor: move;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title-group {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }

        .header-bar h2 {
            margin: 0;
            font-size: 12px;
            font-weight: normal;
            color: #bb86fc;
        }
        
        .version-tag {
            font-size: 11px;
            color: #888;
        }
        
        #refreshBtn {
            background: none;
            border: none;
            color: #a0a0a0;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            line-height: 1;
            transition: color 0.2s, transform 0.2s;
        }
        #refreshBtn:hover {
            color: #03dac6;
            transform: rotate(90deg);
        }
        
        .content-body {
            padding: 10px 15px;
            flex-grow: 1;
            overflow-y: auto; 
            overflow-x: hidden; 
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #status-container {
            padding: 8px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 6px;
            text-align: center;
        }

        #status-text {
            font-size: 16px;
            font-weight: 500;
        }

        #item-list {
            list-style: none;
            padding: 0;
            margin: 10px 0 0 0;
            font-size: 14px;
        }
        #item-list li {
            display: flex;
            justify-content: space-between;
            padding: 5px 2px;
            border-bottom: 1px solid #333;
        }
        #item-list li:last-child {
            border-bottom: none;
        }
        #item-list .item-name {
            color: #ccc;
        }
        #item-list .item-amount {
            color: #03dac6;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="movable-window" id="automationWindow">
        <div class="header-bar" id="dragHandle">
            <div class="title-group">
                <h2>Sawmill Automation & Status</h2>
                <span class="version-tag">v2.3</span>
            </div>
             <button id="refreshBtn" title="Refresh Page">&#x21bb;</button>
        </div>
        <div class="content-body">
            <div id="status-container">
                <span id="status-text">Initializing...</span>
            </div>
             <ul id="item-list">
                <!-- Items will be dynamically inserted here -->
            </ul>
        </div>
    </div>

    <script>
    (() => {
        // --- CONFIGURATION & CONSTANTS ---
        const CONFIG = {
            LOGGING_CAMP_MENU: "Trucking: Logging Camp",
            SAWMILL_MENU: "The Sawmill Faction",
            MAIN_TRAILER_MODEL: "trailerlarge",
            MK15_MODEL: "mk15",
            INVENTORY_LOG_CAPACITY: 5,
            DEBOUNCE_DELAY_MS: 1500
        };

        const ACTIONS = {
            COLLECT_LOGS_10: "Collect Logs x10",
            COLLECT_LOGS_5: "Collect Logs x5",
            DUMP_FROM_TRUNK: "Dump from Trunk",
            OPEN_STORAGE: "Open Storage",
            PUT_ALL: "Put All",
            MOC_TRAILER: "Mobile Operations Center (MK14) (trailerlarge)",
            DUMP_MK15: "Chernobog Toter (mk15)"
        };
        
        const NOTIFICATIONS = {
            INVENTORY_FULL: "~r~Inventory full."
        };

        const itemMap = {
            "tcargodust": "Sawdust",
            "tcargologs": "Logs",
            "refined_planks": "Planks"
        };
        
        // --- STATE & CACHE ---
        let cache = {};
        let lastActionTimestamp = 0;
        let isProcessing = false;
        let fillStep = 'trailer'; // 'trailer', 'cab', or 'inventory'

        // --- UI ELEMENTS ---
        const statusText = document.getElementById('status-text');
        const itemList = document.getElementById('item-list');
        const draggableWindow = document.getElementById('automationWindow');
        const dragHandle = document.getElementById('dragHandle');
        const refreshBtn = document.getElementById('refreshBtn');

        // --- UI & WINDOW LOGIC ---
        let isDragging = false;
        let offsetX, offsetY;
        dragHandle.addEventListener('mousedown', (e) => {
             if (e.target === refreshBtn) return;
            isDragging = true;
            offsetX = e.clientX - draggableWindow.getBoundingClientRect().left;
            offsetY = e.clientY - draggableWindow.getBoundingClientRect().top;
            draggableWindow.style.userSelect = 'none';
        });
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            draggableWindow.style.left = `${e.clientX - offsetX}px`;
            draggableWindow.style.top = `${e.clientY - offsetY}px`;
        });
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                draggableWindow.style.userSelect = 'auto';
            }
        });
        refreshBtn.addEventListener('click', () => window.location.reload());

        // --- CORE AUTOMATION LOGIC ---
        function postCommand(type, data = {}) {
            window.parent.postMessage({ type, ...data }, "*");
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function waitUntil(conditionFn, retries, timeout, errorMessage = "Wait operation timed out.") {
            return new Promise(async (resolve, reject) => {
                while (!conditionFn()) {
                    if (retries-- <= 0) return reject(new Error(errorMessage));
                    await sleep(timeout);
                }
                await sleep(100);
                resolve(true);
            });
        }
        
        async function forceMenuChoice(choiceText) {
            const initialMenuChoices = JSON.stringify(cache.menu_choices);
            const choiceWithTags = cache.menu_choices.find(c => c && typeof c[0] === 'string' && c[0].replace(/(<.+?>)|(&#.+?;)/g, "").trim().includes(choiceText));
            
            if (!choiceWithTags) {
                throw new Error(`Could not find choice containing "${choiceText}"`);
            }

            postCommand("forceMenuChoice", { choice: choiceWithTags[0], mod: 0 });

            if (choiceText === ACTIONS.PUT_ALL) {
                await sleep(200);
                return;
            }

            try {
                await waitUntil(() => JSON.stringify(cache.menu_choices) !== initialMenuChoices, 200, 5);
            } catch (e) { /* It's okay if this times out */ }
        }

        function getStorageContent(storageKey) {
            const content = cache[storageKey];
            if (!content || content === "{}") return { tcargologs: { amount: 0 } };
            try {
                const contentString = typeof content === 'string' ? content : JSON.stringify(content);
                const parsed = JSON.parse(contentString);
                return parsed.tcargologs ? parsed : { tcargologs: { amount: 0 } };
            } catch (e) {
                return { tcargologs: { amount: 0 } };
            }
        }
        
        function getLogAmount(storageKey) {
             return (getStorageContent(storageKey).tcargologs?.amount) || 0;
        }

        async function handleInventoryFull() {
            if (isProcessing) return;
            isProcessing = true;
            
            if (fillStep === 'trailer' && cache.cab === CONFIG.MK15_MODEL) {
                fillStep = 'cab';
                postCommand("sendCommand", { command: "rm_cabtrunk" });
            } else {
                fillStep = 'inventory';
                postCommand("sendCommand", { command: "vrp-reopen" });
            }
            
            await sleep(500);
            isProcessing = false;
        }

        async function handleLoggingCamp() {
            if (isProcessing || Date.now() - lastActionTimestamp < CONFIG.DEBOUNCE_DELAY_MS) return;
            isProcessing = true;

            try {
                const hasMk15 = cache.cab === CONFIG.MK15_MODEL;
                
                if (fillStep === 'inventory') {
                    const inventoryLogAmount = getLogAmount('inventory');
                    if (inventoryLogAmount < CONFIG.INVENTORY_LOG_CAPACITY) {
                        await forceMenuChoice(ACTIONS.COLLECT_LOGS_5);
                    }
                } else { // Start with trailer by default
                    fillStep = 'trailer';
                    await forceMenuChoice(ACTIONS.COLLECT_LOGS_10);
                    await sleep(500);
                    postCommand("sendCommand", { command: "rm_trunk" });
                }
            } finally {
                isProcessing = false;
                lastActionTimestamp = Date.now();
            }
        }

        async function handleSawmill() {
            if (isProcessing || Date.now() - lastActionTimestamp < CONFIG.DEBOUNCE_DELAY_MS) return;
            isProcessing = true;

            try {
                const userId = cache.user_id;
                if (!userId) return;

                const hasMk15 = cache.cab === CONFIG.MK15_MODEL;
                const vehicleStorageKey = `chest_u${userId}veh_trailer_${CONFIG.MAIN_TRAILER_MODEL}`;
                const mk15StorageKey = `chest_u${userId}veh_cab_${CONFIG.MK15_MODEL}`;

                const vehicleLogAmount = getLogAmount(vehicleStorageKey);
                const mk15LogAmount = hasMk15 ? getLogAmount(mk15StorageKey) : 0;
                let inventoryLogAmount = getLogAmount('inventory');

                if (vehicleLogAmount > 0) {
                    await forceMenuChoice(ACTIONS.DUMP_FROM_TRUNK);
                    await waitUntil(() => cache.menu_choices.some(c => c && c[0] && c[0].includes(ACTIONS.MOC_TRAILER)), 100, 10);
                    await forceMenuChoice(ACTIONS.MOC_TRAILER);
                    await waitUntil(() => cache.menu === CONFIG.SAWMILL_MENU, 100, 10, "Sawmill menu did not reappear after trailer dump.");
                }

                if (hasMk15 && getLogAmount(mk15StorageKey) > 0) {
                    await forceMenuChoice(ACTIONS.DUMP_FROM_TRUNK);
                    await waitUntil(() => cache.menu_choices.some(c => c && c[0] && c[0].includes(ACTIONS.DUMP_MK15)), 100, 10);
                    await forceMenuChoice(ACTIONS.DUMP_MK15);
                    await waitUntil(() => cache.menu === CONFIG.SAWMILL_MENU, 100, 10, "Sawmill menu did not reappear after MK15 dump.");
                }
                
                inventoryLogAmount = getLogAmount('inventory');
                if (inventoryLogAmount > 0) {
                    await forceMenuChoice(ACTIONS.OPEN_STORAGE);
                    await waitUntil(() => cache.menu_choices.some(c => c && c[0] && c[0].includes(ACTIONS.PUT_ALL)), 100, 10);
                    await forceMenuChoice(ACTIONS.PUT_ALL);
                }
            } finally {
                isProcessing = false;
                lastActionTimestamp = Date.now();
            }
        }

        function updateUI() {
             const userId = cache.user_id;
             const factionId = cache.faction_id;

             // Update Status Text
             if (!userId) {
                statusText.textContent = "Waiting for User ID...";
             } else {
                const hasMk15 = cache.cab === CONFIG.MK15_MODEL;
                const vehicleStorageKey = `chest_u${userId}veh_trailer_${CONFIG.MAIN_TRAILER_MODEL}`;
                const mk15StorageKey = `chest_u${userId}veh_cab_${CONFIG.MK15_MODEL}`;
                
                const vehicleLogAmount = getLogAmount(vehicleStorageKey);
                const mk15LogAmount = hasMk15 ? getLogAmount(mk15StorageKey) : 0;
                const inventoryLogAmount = getLogAmount('inventory');

                if (vehicleLogAmount > 0 || mk15LogAmount > 0 || inventoryLogAmount > 0) {
                    statusText.textContent = "Waiting for Storage Menu";
                } else {
                    statusText.textContent = "Waiting for Logs Menu";
                }
             }

            // Update Item List (for self-storage only)
            if (!userId || !factionId) {
                itemList.innerHTML = `<li><span class="item-name">Waiting for User/Faction ID...</span></li>`;
                return;
            }
            const storageKey = `chest_self_storage:${userId}:faq_${factionId}:chest`;
            const storageContentRaw = cache[storageKey];
            
            itemList.innerHTML = '';
            
            if (storageContentRaw) {
                try {
                    const storageContent = JSON.parse(storageContentRaw);
                    let othersAmount = 0;
                    let displayedItems = 0;
                    
                    for (const key in itemMap) {
                        if (storageContent[key]) {
                            const li = document.createElement('li');
                            li.innerHTML = `<span class="item-name">${itemMap[key]}</span><span class="item-amount">${storageContent[key].amount.toLocaleString()}</span>`;
                            itemList.appendChild(li);
                            displayedItems++;
                        }
                    }
                    for (const key in storageContent) {
                        if (!itemMap[key]) {
                            othersAmount += storageContent[key].amount;
                        }
                    }
                    if (othersAmount > 0) {
                         const li = document.createElement('li');
                         li.innerHTML = `<span class="item-name">Others</span><span class="item-amount">${othersAmount.toLocaleString()}</span>`;
                         itemList.appendChild(li);
                         displayedItems++;
                    }
                    if (displayedItems === 0) {
                         itemList.innerHTML = `<li><span class="item-name">Self-Storage is empty</span></li>`;
                    }
                } catch (e) {
                     itemList.innerHTML = `<li><span class="item-name">Error parsing storage data</span></li>`;
                }
            } else {
                itemList.innerHTML = `<li><span class="item-name">Open Self-Storage to see items</span></li>`;
            }
        }

        // --- EVENT LISTENERS ---
        window.addEventListener("message", (event) => {
            const data = event.data;
            if (!data || !data.data) return;
            
            const receivedData = data.data;
            
            for (const [key, value] of Object.entries(receivedData)) {
                if (key === 'menu_choices') {
                    if (typeof value === 'string') {
                        try { cache[key] = JSON.parse(value || "[]"); } catch { cache[key] = []; }
                    } else if (Array.isArray(value)) {
                        cache[key] = value;
                    } else {
                        cache[key] = [];
                    }
                } else {
                    cache[key] = value;
                }
            }
            
            if (receivedData.notification === NOTIFICATIONS.INVENTORY_FULL) {
                handleInventoryFull();
            }
            
            updateUI();
            
            if (cache.menu_open && Array.isArray(cache.menu_choices)) {
                const menuText = cache.menu_choices.map(c => c && c[0] ? c[0].replace(/(<.+?>)|(&#.+?;)/g, "").trim() : "").join(" ");
                
                if (menuText.includes("Collect Logs")) {
                    handleLoggingCamp();
                } else if (menuText.includes(ACTIONS.DUMP_FROM_TRUNK) || menuText.includes(ACTIONS.OPEN_STORAGE)) {
                    handleSawmill();
                }
            }
        });

        document.addEventListener("DOMContentLoaded", function() {
            postCommand("getData");
            updateUI();

            const escapeListener = (e) => {
                if (e.key === "Escape") {
                    postCommand("pin");
                }
            };
            window.addEventListener('keydown', escapeListener);
        });
    })();
    </script>
</body>
</html>

